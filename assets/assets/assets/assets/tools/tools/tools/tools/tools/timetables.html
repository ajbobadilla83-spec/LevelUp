<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Times Table Challenge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

  <style>
    body { font-family: 'Inter', sans-serif; }

    /* Hide number input arrows */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }

    .correct-input {
      background-color: #dcfce7 !important; /* green-100 */
      color: #166534; /* green-800 */
      font-weight: bold;
    }
    .incorrect-input { background-color: #fee2e2 !important; /* red-100 */ }

    .incorrect-cell { position: relative; }
    .unanswered {
      background-color: #e5e7eb; /* gray-200 */
      text-align: center;
      vertical-align: middle;
    }
    .correct-answer-text {
      color: #b91c1c; /* red-700 */
      font-size: 0.75rem;
      font-weight: bold;
      display: block;
      margin-top: -2px;
    }
    .unanswered-text {
      color: #374151; /* gray-700 */
      font-size: 1rem;
      font-weight: bold;
    }

    /* Focus / disabled cells */
    .practice-disabled {
      background-color: #f3f4f6 !important; /* gray-100 */
      color: #9ca3af !important; /* gray-400 */
      cursor: not-allowed;
    }
    .cell-dim {
      background-color: #f9fafb; /* gray-50 */
    }
    .selected-cell-ring {
      outline: 3px solid rgba(59,130,246,0.45); /* blue-500 */
      outline-offset: -2px;
      border-radius: 0.25rem;
    }
  </style>

  <link rel="manifest" href="manifest.json">
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen py-8">
  <main class="bg-white p-4 sm:p-6 md:p-8 rounded-2xl shadow-xl w-full max-w-7xl mx-4">

    <!-- Header -->
    <header class="text-center mb-6">
      <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">Times Table Challenge</h1>
      <p class="text-gray-500 mt-1">Fill in the grid. You have 10 minutes (or practise untimed in drill mode).</p>
    </header>

    <!-- Controls and Status -->
    <div class="flex flex-col gap-4 mb-6 border-b pb-6">
      <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="flex items-center gap-3 flex-wrap">
          <button id="startButton"
            class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
            Start Game
          </button>

          <button id="finishButton"
            class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition-colors shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
            disabled>
            Finished!
          </button>

          <div class="flex items-center gap-2 bg-gray-50 border rounded-lg px-3 py-2">
            <label for="practiceMode" class="text-sm font-semibold text-gray-700">Practice Focus:</label>
            <select id="practiceMode" class="text-sm border rounded-md px-2 py-1">
              <option value="mixed">Mixed (All)</option>
              <option value="table">One Table (Row + Column)</option>
            </select>

            <select id="focusTable" class="text-sm border rounded-md px-2 py-1" disabled>
              <!-- options inserted by JS -->
            </select>
          </div>

          <label class="flex items-center gap-2 bg-gray-50 border rounded-lg px-3 py-2">
            <input id="instantFeedbackToggle" type="checkbox" class="h-4 w-4" />
            <span class="text-sm font-semibold text-gray-700">Instant feedback</span>
          </label>
        </div>

        <div class="flex items-center gap-6 flex-wrap justify-center sm:justify-end">
          <div id="timer" class="text-2xl font-bold bg-gray-100 text-gray-700 px-4 py-2 rounded-lg shadow-inner">10:00</div>
          <div id="score" class="text-lg font-bold text-gray-700">Score: <span id="scoreValue" class="text-blue-600">--</span></div>
        </div>
      </div>

      <!-- Small helper message line -->
      <div class="text-center text-sm text-gray-500">
        Tip: Click a box to get a skip-count helper and hints.
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex flex-col lg:flex-row gap-8">
      <!-- Times Table Grid -->
      <div id="grid-container" class="overflow-x-auto lg:w-2/3">
        <!-- grid generated here -->
      </div>

      <!-- Helper + Results Column -->
      <div class="lg:w-1/3 flex flex-col gap-6">
        <!-- Helper Panel (NEW) -->
        <section id="helper-panel" class="p-6 bg-blue-50 border border-blue-200 rounded-xl">
          <h2 class="text-xl font-bold text-gray-800 mb-2">Helper</h2>

          <div class="flex items-center justify-between gap-2 mb-3">
            <div class="text-sm text-gray-700">
              Selected: <span id="selectedCellLabel" class="font-bold text-blue-700">—</span>
            </div>
            <button id="clearSelectionBtn"
              class="text-sm px-3 py-1 rounded-md border bg-white hover:bg-gray-50">
              Clear
            </button>
          </div>

          <div id="helperContent" class="text-sm text-gray-700 space-y-3">
            <p class="text-gray-600">Select a grid box to see skip-counting and hints.</p>
          </div>

          <div class="mt-4 flex flex-wrap gap-2">
            <button id="nextJumpBtn"
              class="px-3 py-2 rounded-lg bg-white border hover:bg-gray-50 text-sm font-semibold disabled:opacity-50"
              disabled>
              Next jump
            </button>

            <button id="autoJumpBtn"
              class="px-3 py-2 rounded-lg bg-white border hover:bg-gray-50 text-sm font-semibold disabled:opacity-50"
              disabled>
              Auto
            </button>

            <button id="hintBtn"
              class="px-3 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 text-sm font-semibold disabled:opacity-50"
              disabled>
              Hint (step 1)
            </button>

            <button id="resetHintBtn"
              class="px-3 py-2 rounded-lg bg-white border hover:bg-gray-50 text-sm font-semibold disabled:opacity-50"
              disabled>
              Reset hints
            </button>
          </div>

          <div class="mt-3 text-xs text-gray-500">
            Hint ladder: 1) repeated addition, 2) skip-count list, 3) answer (only if needed).
          </div>
        </section>

        <!-- Results Panel -->
        <section id="results-panel" class="p-6 bg-gray-50 rounded-xl hidden">
          <h2 id="resultsTitle" class="text-2xl font-bold text-gray-800 mb-4 text-center">Challenge Complete!</h2>
          <div class="text-center" id="resultsContent">
            <p class="text-gray-600 text-lg mb-2">Here's how you did:</p>
            <p class="text-4xl font-bold text-blue-600 my-4" id="resultsScore"></p>
            <p class="text-gray-500" id="resultsTime"></p>

            <div id="miniReportHolder" class="mt-6"></div>

            <!-- Targeted Practice Buttons (NEW) -->
            <div class="mt-6 flex flex-col gap-2">
              <button id="practiceWeakBtn"
                class="bg-yellow-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-yellow-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500">
                Practise my weak table(s)
              </button>
              <button id="practiceMissedBtn"
                class="bg-orange-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-orange-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500">
                Practise just the facts I missed
              </button>
              <button id="playAgainButton"
                class="mt-2 bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                Play Again
              </button>
            </div>

            <!-- Drill Area (NEW) -->
            <div id="drillArea" class="hidden mt-6 text-left p-4 bg-white border rounded-lg">
              <div class="flex items-start justify-between gap-3">
                <div>
                  <div class="text-sm text-gray-500">Drill (untimed)</div>
                  <div class="text-lg font-bold text-gray-800" id="drillTitle">Practice</div>
                </div>
                <button id="exitDrillBtn" class="text-sm px-3 py-1 rounded-md border hover:bg-gray-50">Exit drill</button>
              </div>

              <div class="mt-4">
                <div class="text-sm text-gray-600">Question</div>
                <div class="text-2xl font-bold text-gray-800 mt-1" id="drillQuestion">—</div>
              </div>

              <div class="mt-3 flex items-center gap-2">
                <input id="drillAnswer" type="number"
                  class="w-28 text-center border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400"
                  placeholder="Answer" />
                <button id="drillCheckBtn"
                  class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">
                  Check
                </button>
                <button id="drillHintBtn"
                  class="bg-white border font-bold py-2 px-4 rounded-lg hover:bg-gray-50">
                  Hint
                </button>
              </div>

              <div id="drillFeedback" class="mt-3 text-sm"></div>

              <div class="mt-4 flex items-center justify-between">
                <div class="text-sm text-gray-600">Progress: <span id="drillProgress" class="font-bold">0/0</span></div>
                <button id="drillNextBtn"
                  class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 disabled:opacity-50"
                  disabled>
                  Next
                </button>
              </div>
            </div>

          </div>
        </section>
      </div>
    </div>
  </main>

  <script>
    // --- DOM Elements ---
    const startButton = document.getElementById('startButton');
    const finishButton = document.getElementById('finishButton');
    const gridContainer = document.getElementById('grid-container');
    const timerDisplay = document.getElementById('timer');
    const scoreValue = document.getElementById('scoreValue');

    const practiceMode = document.getElementById('practiceMode');
    const focusTable = document.getElementById('focusTable');
    const instantFeedbackToggle = document.getElementById('instantFeedbackToggle');

    const helperPanel = document.getElementById('helper-panel');
    const helperContent = document.getElementById('helperContent');
    const selectedCellLabel = document.getElementById('selectedCellLabel');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const nextJumpBtn = document.getElementById('nextJumpBtn');
    const autoJumpBtn = document.getElementById('autoJumpBtn');
    const hintBtn = document.getElementById('hintBtn');
    const resetHintBtn = document.getElementById('resetHintBtn');

    const resultsPanel = document.getElementById('results-panel');
    const resultsTitle = document.getElementById('resultsTitle');
    const resultsScore = document.getElementById('resultsScore');
    const resultsTime = document.getElementById('resultsTime');
    const playAgainButton = document.getElementById('playAgainButton');
    const miniReportHolder = document.getElementById('miniReportHolder');
    const practiceWeakBtn = document.getElementById('practiceWeakBtn');
    const practiceMissedBtn = document.getElementById('practiceMissedBtn');

    const drillArea = document.getElementById('drillArea');
    const drillTitle = document.getElementById('drillTitle');
    const drillQuestion = document.getElementById('drillQuestion');
    const drillAnswer = document.getElementById('drillAnswer');
    const drillCheckBtn = document.getElementById('drillCheckBtn');
    const drillHintBtn = document.getElementById('drillHintBtn');
    const drillFeedback = document.getElementById('drillFeedback');
    const drillNextBtn = document.getElementById('drillNextBtn');
    const drillProgress = document.getElementById('drillProgress');
    const exitDrillBtn = document.getElementById('exitDrillBtn');

    // --- Game State ---
    const GRID_SIZE = 12;
    const GAME_DURATION = 600; // 10 minutes
    let timerInterval = null;
    let timeLeft = GAME_DURATION;
    let gameActive = false;

    // Selected cell state (for helper panel)
    let selectedCell = null; // { r, c, inputEl }
    let skipStep = 0;
    let hintStep = 0;
    let autoJumpInterval = null;

    // End-game analysis (for targeted practice)
    let lastMistakesByTable = {};
    let lastWeakestTables = [];
    let lastMissedPairs = []; // [{r,c}]
    let lastMaxMistakes = 0;

    // Drill mode state
    let drillActive = false;
    let drillQuestions = []; // [{r,c}]
    let drillIndex = 0;
    let drillHintStep = 0;

    // --- Helpers ---
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function cellId(r, c) { return `cell-${r}-${c}`; }
    function parseCellId(id) {
      const parts = id.split('-').map(Number);
      return { r: parts[1], c: parts[2] };
    }
    function correctAnswer(r, c) { return r * c; }

    function clearIntervals() {
      if (autoJumpInterval) { clearInterval(autoJumpInterval); autoJumpInterval = null; }
    }

    function setHelperEmpty() {
      selectedCell = null;
      skipStep = 0;
      hintStep = 0;
      selectedCellLabel.textContent = '—';
      helperContent.innerHTML = `<p class="text-gray-600">Select a grid box to see skip-counting and hints.</p>`;
      nextJumpBtn.disabled = true;
      autoJumpBtn.disabled = true;
      hintBtn.disabled = true;
      resetHintBtn.disabled = true;
      hintBtn.textContent = 'Hint (step 1)';
      clearIntervals();
      document.querySelectorAll('#grid-container input').forEach(i => i.classList.remove('selected-cell-ring'));
    }

    function buildSkipList(factor, count) {
      const arr = [];
      for (let i = 1; i <= count; i++) arr.push(factor * i);
      return arr;
    }

    function renderHelperBase(r, c) {
      const a = r;
      const b = c;
      const ans = correctAnswer(r, c);
      const baseFactor = a; // skip count by row number
      const steps = buildSkipList(baseFactor, b);
      helperContent.innerHTML = `
        <div class="space-y-2">
          <div class="text-gray-800">
            <span class="font-bold">${a} × ${b}</span>
            <span class="text-gray-500"> (answer is built by counting in jumps)</span>
          </div>

          <div class="bg-white border rounded-lg p-3">
            <div class="text-xs font-bold text-gray-500 mb-1">Skip-count by ${baseFactor} (up to ${b} jumps)</div>
            <div id="skipLine" class="text-sm text-gray-800 break-words">Click <span class="font-semibold">Next jump</span> to begin.</div>
          </div>

          <div id="instantFeedbackHint" class="text-sm"></div>

          <div class="text-xs text-gray-500">
            You can also use the Hint button for step-by-step support.
          </div>
        </div>
      `;
    }

    function updateSkipLine(r, c) {
      const skipLine = document.getElementById('skipLine');
      if (!skipLine) return;

      const baseFactor = r;
      const totalJumps = c;
      const jumps = buildSkipList(baseFactor, totalJumps);

      const shown = jumps.slice(0, skipStep);
      if (skipStep === 0) {
        skipLine.textContent = `Click Next jump to begin.`;
        return;
      }
      if (skipStep >= totalJumps) {
        skipLine.innerHTML = `Jumps: <span class="font-semibold">${shown.join(', ')}</span> ✅`;
        return;
      }
      skipLine.innerHTML = `Jumps: <span class="font-semibold">${shown.join(', ')}</span> …`;
    }

    function showInstantHintMessage(message, type='info') {
      const holder = document.getElementById('instantFeedbackHint');
      if (!holder) return;
      const cls = type === 'good'
        ? 'text-green-700'
        : type === 'bad'
          ? 'text-red-700'
          : 'text-gray-700';
      holder.innerHTML = `<div class="${cls}"><span class="font-bold">${message}</span></div>`;
    }

    function applyPracticeFocus() {
      const mode = practiceMode.value; // mixed or table
      const t = Number(focusTable.value);

      const inputs = document.querySelectorAll('#grid-container input');
      inputs.forEach(input => {
        const { r, c } = parseCellId(input.id);
        const allowed = (mode === 'mixed') ? true : (r === t || c === t);

        // Only affect enabled state if game is active; keep disabled if not started.
        const shouldDisableByFocus = !allowed;
        input.dataset.focusAllowed = allowed ? '1' : '0';

        // styling
        input.classList.toggle('practice-disabled', shouldDisableByFocus);
        input.parentElement.classList.toggle('cell-dim', shouldDisableByFocus);

        // disable only when game is active (so students can see focus even before start, but still disabled anyway)
        if (gameActive) {
          input.disabled = shouldDisableByFocus ? true : false;
        }
      });

      // if selected cell becomes disallowed, clear selection
      if (selectedCell) {
        const allowed = selectedCell.inputEl.dataset.focusAllowed === '1';
        if (!allowed) setHelperEmpty();
      }
    }

    function resetCheckStyling(input) {
      input.classList.remove('correct-input', 'incorrect-input');
      input.parentElement.classList.remove('incorrect-cell');
      // remove any appended correct answer spans (endgame styling)
      const extras = input.parentElement.querySelectorAll('.correct-answer-text, .unanswered-text');
      extras.forEach(e => e.remove());
      input.style.display = '';
      input.parentElement.classList.remove('unanswered');
    }

    function checkSingleInput(input, { silent=false } = {}) {
      const { r, c } = parseCellId(input.id);
      const correct = correctAnswer(r, c);
      const val = input.value;

      resetCheckStyling(input);

      if (val === '') {
        if (!silent && selectedCell && selectedCell.inputEl === input) {
          showInstantHintMessage(`Try skip-counting by ${r} for ${c} jumps.`, 'info');
        }
        return { status: 'empty', correct };
      }

      const isRight = parseInt(val, 10) === correct;
      if (isRight) {
        input.classList.add('correct-input');
        if (!silent && selectedCell && selectedCell.inputEl === input) {
          showInstantHintMessage(`Correct!`, 'good');
        }
        return { status: 'correct', correct };
      } else {
        input.classList.add('incorrect-input');
        if (!silent && selectedCell && selectedCell.inputEl === input) {
          showInstantHintMessage(`Not quite. Use Next jump or Hint step 1.`, 'bad');
        }
        return { status: 'incorrect', correct };
      }
    }

    // --- Grid Creation ---
    function createGrid() {
      gridContainer.innerHTML = '';
      const table = document.createElement('table');
      table.className = 'w-full border-collapse text-center';

      const thead = table.createTHead();
      const headerRow = thead.insertRow();
      headerRow.className = 'bg-gray-200';
      headerRow.insertCell().className = 'p-2';
      for (let i = 1; i <= GRID_SIZE; i++) {
        const th = document.createElement('th');
        th.className = 'p-2 sm:p-3 text-sm sm:text-base font-bold text-gray-600 border border-gray-300';
        th.textContent = i;
        headerRow.appendChild(th);
      }

      const tbody = table.createTBody();
      for (let r = 1; r <= GRID_SIZE; r++) {
        const row = tbody.insertRow();
        const th = document.createElement('th');
        th.className = 'p-2 sm:p-3 text-sm sm:text-base font-bold text-gray-600 bg-gray-200 border border-gray-300';
        th.textContent = r;
        row.appendChild(th);

        for (let c = 1; c <= GRID_SIZE; c++) {
          const cell = row.insertCell();
          cell.className = 'border border-gray-300';

          const input = document.createElement('input');
          input.type = 'number';
          input.id = cellId(r, c);
          input.className = 'w-full h-10 sm:h-12 text-center bg-white focus:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-blue-400 transition-colors rounded-none';
          input.disabled = true;

          // Selection + helper
          input.addEventListener('focus', () => {
            if (drillActive) return;
            if (!gameActive) return;

            // If focus mode disallows this cell, block focus behaviour
            if (input.dataset.focusAllowed === '0') {
              input.blur();
              return;
            }

            document.querySelectorAll('#grid-container input').forEach(i => i.classList.remove('selected-cell-ring'));
            input.classList.add('selected-cell-ring');

            selectedCell = { r, c, inputEl: input };
            selectedCellLabel.textContent = `${r} × ${c}`;
            skipStep = 0;
            hintStep = 0;
            clearIntervals();
            renderHelperBase(r, c);
            updateSkipLine(r, c);

            nextJumpBtn.disabled = false;
            autoJumpBtn.disabled = false;
            hintBtn.disabled = false;
            resetHintBtn.disabled = false;
            hintBtn.textContent = 'Hint (step 1)';

            // If instant feedback is on and there is already an answer, re-check and show message
            if (instantFeedbackToggle.checked) checkSingleInput(input);
          });

          // Instant feedback on blur or Enter
          input.addEventListener('blur', () => {
            if (!gameActive) return;
            if (!instantFeedbackToggle.checked) return;
            if (input.dataset.focusAllowed === '0') return;
            checkSingleInput(input);
          });

          input.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            if (input.dataset.focusAllowed === '0') return;

            if (e.key === 'Enter') {
              e.preventDefault();
              if (instantFeedbackToggle.checked) checkSingleInput(input);
              // move to next cell (simple: same row, next col)
              const nextC = (c < GRID_SIZE) ? c + 1 : 1;
              const nextR = (c < GRID_SIZE) ? r : Math.min(GRID_SIZE, r + 1);
              const next = document.getElementById(cellId(nextR, nextC));
              if (next && next.dataset.focusAllowed === '1') next.focus();
            }
          });

          cell.appendChild(input);
        }
      }

      gridContainer.appendChild(table);
    }

    // --- Game Flow ---
    function resetGameVisuals() {
      createGrid();
      setHelperEmpty();
      applyPracticeFocus();
    }

    function startGame() {
      if (gameActive) return;
      drillActive = false;
      drillArea.classList.add('hidden');

      gameActive = true;
      resultsPanel.classList.add('hidden');
      miniReportHolder.innerHTML = '';

      resetGameVisuals();

      // enable inputs according to focus
      document.querySelectorAll('#grid-container input').forEach(input => {
        const allowed = input.dataset.focusAllowed !== '0';
        input.disabled = !allowed;
      });

      finishButton.disabled = false;
      startButton.textContent = 'Reset';

      timeLeft = GAME_DURATION;
      timerDisplay.textContent = formatTime(timeLeft);

      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        timerDisplay.textContent = formatTime(timeLeft);
        if (timeLeft <= 0) endGame('Time is up!');
      }, 1000);
    }

    function endGame(title) {
      if (!gameActive) return;

      clearInterval(timerInterval);
      gameActive = false;

      clearIntervals();

      let correctAnswers = 0;
      const totalQuestions = GRID_SIZE * GRID_SIZE;

      lastMissedPairs = [];
      lastMistakesByTable = {};
      for (let t = 1; t <= GRID_SIZE; t++) lastMistakesByTable[t] = 0;

      finishButton.disabled = true;

      // end-of-game marking (kept from your original)
      document.querySelectorAll('#grid-container input').forEach(input => {
        input.disabled = true;

        const { r, c } = parseCellId(input.id);
        const correct = correctAnswer(r, c);
        const userAnswer = input.value;
        const cell = input.parentElement;

        // focus-disabled cells: still count in total score the same as before (full grid),
        // but they might be empty if you used focus mode.
        // We'll treat empty or wrong as missed for targeted practice.
        if (userAnswer === '' || parseInt(userAnswer, 10) !== correct) {
          lastMissedPairs.push({ r, c });
          lastMistakesByTable[r] += 1;
          lastMistakesByTable[c] += 1;
        }

        if (userAnswer === '') {
          cell.classList.add('unanswered');
          input.style.display = 'none';
          const span = document.createElement('span');
          span.className = 'unanswered-text';
          span.textContent = correct;
          cell.appendChild(span);
        } else if (parseInt(userAnswer, 10) === correct) {
          correctAnswers++;
          input.classList.add('correct-input');
        } else {
          cell.classList.add('incorrect-cell');
          input.classList.add('incorrect-input');
          const span = document.createElement('span');
          span.className = 'correct-answer-text';
          span.textContent = correct;
          cell.appendChild(span);
        }
      });

      const score = `${correctAnswers} / ${totalQuestions}`;
      scoreValue.textContent = score;

      resultsTitle.textContent = title;
      resultsScore.textContent = score;

      const timeTaken = GAME_DURATION - timeLeft;
      resultsTime.textContent = `Completed in ${formatTime(timeTaken)}.`;
      resultsPanel.classList.remove('hidden');

      // Mini report (improved + stored)
      lastMaxMistakes = Math.max(...Object.values(lastMistakesByTable));
      lastWeakestTables = Object.keys(lastMistakesByTable)
        .filter(t => lastMistakesByTable[t] === lastMaxMistakes && lastMaxMistakes > 0)
        .map(Number);

      miniReportHolder.innerHTML = '';
      const reportDiv = document.createElement('div');
      reportDiv.className = 'p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-yellow-800';
      if (lastMaxMistakes > 0) {
        reportDiv.innerHTML =
          `<strong>Mini Report:</strong> You had the most trouble with the ${lastWeakestTables.join(', ')}× table${lastWeakestTables.length > 1 ? 's' : ''} (${lastMaxMistakes} mistakes).`;
      } else {
        reportDiv.innerHTML = `<strong>Mini Report:</strong> Amazing! You got them all correct — no weak tables this time.`;
      }
      miniReportHolder.appendChild(reportDiv);

      // Clear helper selection
      setHelperEmpty();
    }

    function resetGame() {
      clearInterval(timerInterval);
      clearIntervals();

      gameActive = false;
      drillActive = false;

      timeLeft = GAME_DURATION;
      timerDisplay.textContent = formatTime(GAME_DURATION);
      scoreValue.textContent = '--';

      finishButton.disabled = true;
      startButton.textContent = 'Start Game';

      resultsPanel.classList.add('hidden');
      drillArea.classList.add('hidden');

      resetGameVisuals();
    }

    // --- Helper Buttons (Skip Counting + Hint Ladder) ---
    function nextJump() {
      if (!selectedCell) return;
      const { r, c } = selectedCell;

      if (skipStep < c) skipStep++;
      updateSkipLine(r, c);
    }

    function autoJump() {
      if (!selectedCell) return;
      const { c } = selectedCell;

      if (autoJumpInterval) {
        clearIntervals();
        autoJumpBtn.textContent = 'Auto';
        return;
      }

      autoJumpBtn.textContent = 'Stop';
      autoJumpInterval = setInterval(() => {
        if (!selectedCell) { clearIntervals(); autoJumpBtn.textContent = 'Auto'; return; }
        const { r, c } = selectedCell;
        if (skipStep < c) {
          skipStep++;
          updateSkipLine(r, c);
        } else {
          clearIntervals();
          autoJumpBtn.textContent = 'Auto';
        }
      }, 550);
    }

    function hintLadder() {
      if (!selectedCell) return;
      const { r, c } = selectedCell;
      const ans = correctAnswer(r, c);

      hintStep = Math.min(3, hintStep + 1);
      hintBtn.textContent = `Hint (step ${Math.min(3, hintStep + 1)})`;

      // Ensure helper base exists
      if (!document.getElementById('skipLine')) renderHelperBase(r, c);

      if (hintStep === 1) {
        // repeated addition
        const add = Array.from({ length: c }, () => r).join(' + ');
        showInstantHintMessage(`Step 1: ${r}×${c} = ${add}`, 'info');
      } else if (hintStep === 2) {
        // skip list
        const steps = buildSkipList(r, c);
        showInstantHintMessage(`Step 2: Count by ${r}: ${steps.join(', ')}`, 'info');
      } else if (hintStep === 3) {
        // answer
        showInstantHintMessage(`Step 3: The answer is ${ans}. Now try typing it in the box.`, 'info');
      }
    }

    function resetHints() {
      if (!selectedCell) return;
      hintStep = 0;
      skipStep = 0;
      hintBtn.textContent = 'Hint (step 1)';
      renderHelperBase(selectedCell.r, selectedCell.c);
      updateSkipLine(selectedCell.r, selectedCell.c);
    }

    // --- Targeted Practice (Drill Mode) ---
    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function buildWeakTableQuestions(weakTables, count = 12) {
      if (!weakTables || weakTables.length === 0) return [];
      const qs = [];
      for (let i = 0; i < count; i++) {
        const t = weakTables[Math.floor(Math.random() * weakTables.length)];
        const other = 1 + Math.floor(Math.random() * GRID_SIZE);
        // Randomly decide whether table is row or column
        if (Math.random() < 0.5) qs.push({ r: t, c: other });
        else qs.push({ r: other, c: t });
      }
      return qs;
    }

    function startDrill(title, questions) {
      if (!questions || questions.length === 0) {
        alert('No questions available for this drill yet.');
        return;
      }

      drillActive = true;
      gameActive = false;
      clearInterval(timerInterval);
      clearIntervals();

      // Hide grid marking focus (grid remains visible but disabled)
      document.querySelectorAll('#grid-container input').forEach(i => i.disabled = true);
      setHelperEmpty();

      drillQuestions = shuffle(questions);
      drillIndex = 0;
      drillHintStep = 0;

      drillTitle.textContent = title;
      drillArea.classList.remove('hidden');

      renderDrillQuestion();
    }

    function renderDrillQuestion() {
      const q = drillQuestions[drillIndex];
      const total = drillQuestions.length;

      drillQuestion.textContent = `${q.r} × ${q.c}`;
      drillProgress.textContent = `${drillIndex + 1}/${total}`;

      drillAnswer.value = '';
      drillAnswer.focus();

      drillFeedback.textContent = '';
      drillFeedback.className = 'mt-3 text-sm text-gray-700';

      drillNextBtn.disabled = true;
      drillHintStep = 0;
    }

    function drillHint() {
      const q = drillQuestions[drillIndex];
      drillHintStep = Math.min(3, drillHintStep + 1);

      const ans = correctAnswer(q.r, q.c);
      if (drillHintStep === 1) {
        const add = Array.from({ length: q.c }, () => q.r).join(' + ');
        drillFeedback.className = 'mt-3 text-sm text-gray-700';
        drillFeedback.textContent = `Hint 1: ${q.r}×${q.c} = ${add}`;
      } else if (drillHintStep === 2) {
        const steps = buildSkipList(q.r, q.c);
        drillFeedback.className = 'mt-3 text-sm text-gray-700';
        drillFeedback.textContent = `Hint 2: Count by ${q.r}: ${steps.join(', ')}`;
      } else {
        drillFeedback.className = 'mt-3 text-sm text-gray-700';
        drillFeedback.textContent = `Hint 3: The answer is ${ans}.`;
      }
    }

    function drillCheck() {
      const q = drillQuestions[drillIndex];
      const ans = correctAnswer(q.r, q.c);
      const val = drillAnswer.value;

      if (val === '') {
        drillFeedback.className = 'mt-3 text-sm text-red-700';
        drillFeedback.textContent = 'Please type an answer first.';
        return;
      }

      const isRight = parseInt(val, 10) === ans;
      if (isRight) {
        drillFeedback.className = 'mt-3 text-sm text-green-700 font-bold';
        drillFeedback.textContent = 'Correct!';
        drillNextBtn.disabled = false;
      } else {
        drillFeedback.className = 'mt-3 text-sm text-red-700 font-bold';
        drillFeedback.textContent = 'Not quite. Try a hint.';
        drillNextBtn.disabled = true;
      }
    }

    function drillNext() {
      if (drillIndex < drillQuestions.length - 1) {
        drillIndex++;
        renderDrillQuestion();
      } else {
        drillFeedback.className = 'mt-3 text-sm text-green-700 font-bold';
        drillFeedback.textContent = 'Drill complete! Great effort.';
        drillNextBtn.disabled = true;
      }
    }

    function exitDrill() {
      drillActive = false;
      drillArea.classList.add('hidden');
      // Keep results panel visible for the student to choose another drill or play again
    }

    // --- Populate Focus Table Dropdown ---
    function populateFocusDropdown() {
      focusTable.innerHTML = '';
      for (let i = 1; i <= GRID_SIZE; i++) {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `${i}× table`;
        focusTable.appendChild(opt);
      }
      focusTable.value = '2';
    }

    // --- Event Listeners ---
    startButton.addEventListener('click', () => {
      if (startButton.textContent === 'Reset') resetGame();
      else startGame();
    });

    finishButton.addEventListener('click', () => {
      if (gameActive) endGame('Challenge Complete!');
    });

    playAgainButton.addEventListener('click', resetGame);

    practiceMode.addEventListener('change', () => {
      focusTable.disabled = practiceMode.value !== 'table';
      applyPracticeFocus();
    });

    focusTable.addEventListener('change', applyPracticeFocus);

    instantFeedbackToggle.addEventListener('change', () => {
      // If turning on while a cell is selected, re-check it to show feedback immediately.
      if (instantFeedbackToggle.checked && selectedCell) checkSingleInput(selectedCell.inputEl);
    });

    clearSelectionBtn.addEventListener('click', setHelperEmpty);
    nextJumpBtn.addEventListener('click', nextJump);
    autoJumpBtn.addEventListener('click', autoJump);
    hintBtn.addEventListener('click', hintLadder);
    resetHintBtn.addEventListener('click', resetHints);

    practiceWeakBtn.addEventListener('click', () => {
      const qs = buildWeakTableQuestions(lastWeakestTables, 12);
      startDrill('Weak table(s) drill', qs);
    });

    practiceMissedBtn.addEventListener('click', () => {
      // Use missed facts (cap to 24 to keep it manageable)
      const qs = lastMissedPairs.slice(0, 24);
      startDrill('Missed facts drill', qs);
    });

    drillCheckBtn.addEventListener('click', drillCheck);
    drillHintBtn.addEventListener('click', drillHint);
    drillNextBtn.addEventListener('click', drillNext);
    exitDrillBtn.addEventListener('click', exitDrill);

    drillAnswer.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        drillCheck();
      }
    });

    // Initial setup
    window.addEventListener('DOMContentLoaded', () => {
      populateFocusDropdown();
      createGrid();
      setHelperEmpty();
      applyPracticeFocus();
      timerDisplay.textContent = formatTime(GAME_DURATION);
    });
  </script>
</body>
</html>
